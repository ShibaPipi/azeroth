## 计算机的高速缓存

>### 高速缓存的工作原理
* 前置知识
    * 字
        * 指存放在一个存储单元中的二进制代码组合
    * 字块
        * 指存储在连续存储单元种被看作一个单元的 `一组` 字
    * 假设主存可以表示 2<sup>n</sup> 个字，一个字就可以理解为主存内部的一个存储单元，字块可以包含多个字，并且他们的存储是连续的
    * 假设一个字有 32 位，一个字块有 B 个字，主存中有 M 个字块
    * 那么，`B * M = 主存总字数`， `B * M * 32 = 主存总容量（bits）`
    * 字的地址
        * 包含两个部分
        * 前 m 位 指定字块的地址
        * 后 b 位指定自在字块中的地址
        
            | 前半部分 | 后半部分 |
            | :----: | :----: |
            | m 位 | b 位 |
        
        * 依然假设一个字有 32 位，一个字块有 B 个字，主存中有 M 个字块
            * 2<sup>m</sup> = M
            * 2<sup>b</sup> = B
    * 例：假设主存用户空间容量为 4G，字块大小为 M，字长位 32 位，则对于字地址中块地址 m 和块内地址 b 的 位数，至少应该是多少？
        * 4G = 4096M
        * 字块数：4096 / 4 = 1024
        * 字块地址 m：log<sub>2</sub>1024 = 10
        * 块内字总数：4M / 32bits = 1048576
        * 块内地址 b：log<sub>2</sub>1048576 = 20
        * 结果 `m ≥ 10，b ≥ 20`
* 高速缓存
    * 特点
        * 与主存的存储的逻辑结构类似
        * 容量远小于主存，内部存储的数据是主存的复制，每个数据均来自于主存
        * 速度更快
    * 假设一个字有 32 位，一个字块有 B 个字，缓存中有 C 个字块

        | 前半部分 | 后半部分 |
        | :----: | :----: |
        | c 位 | b 位 |
    
        * 2<sup>c</sup> = C
        * 2<sup>b</sup> = B
    * 如何工作
        * 场景一：CPU 需要的数据在缓存里
        * 场景二：CPU 需要的数据不在缓存里，此时需要从主存取数据（大大降低了 CPU 的效率，需要 CPU 尽可能的从高速缓存内取数据）
    * CPU 从高速缓存种取数据成功的几率 —— 缓存命中率
        * 命中率是衡量缓存的重要性能指标
        * 理论上 CPU 每次都能从高速缓存取数据的时候，命中率为 1
        * 假设访问主存次数：N<sub>m</sub>，访问 cache 次数：N<sub>c</sub>
        * 则命中计算公式为：h = N<sub>c</sub> / ( N<sub>c</sub> + N<sub>m</sub> )
    * 访问效率 e
        * 假设访问主存时间：t<sub>m</sub>，访问 cache 时间 t<sub>c</sub>
        * 则访问 `缓存 - 主存` 系统的平均时间：t<sub>a</sub> = h t<sub>c</sub> + ( 1 - h ) t<sub>m</sub>
        * e = t<sub>c</sub> / t<sub>a</sub> = t<sub>c</sub> / ( h t<sub>c</sub> + ( 1 - h ) t<sub>m</sub>)
    * 例：假设 CPU 在执行某段程序时，共访问了缓存命中 2000 次，访问主存 50 次，已知缓存的存取时间为 50 ns（纳秒），主存的存取时间为 200 ns，求缓存 - 主存系统的命中率，访问效率和平均访问时间
        * h = N<sub>c</sub> / ( N<sub>c</sub> + N<sub>m</sub> ) = 2000 / ( 2000 + 50 ) = 0.97
        * e = t<sub>c</sub> / t<sub>a</sub> = t<sub>c</sub> / ( h t<sub>c</sub> + ( 1 - h ) t<sub>m</sub>) = 50 / ( 0.97 * 50 + ( 1 - 0.97 ) * 200 ) = 0.917
        * t<sub>a</sub> = h t<sub>c</sub> + ( 1 - h ) t<sub>m</sub> = 0.97 * 50 + ( 1 - 0.97 ) * 200 = 54.5ns

>### 高速缓存的替换策略
* `高速缓存的替换时机`：当CPU需要的数据不再高度缓存中，需要从主存中载入所需要的数据，替换到高速缓存中
* 策略
    * 随机算法
        * 在需要发生替换时，随机选取高速缓存中的位置，把相关内容替换
    * 先进先出算法（FIFO）
        * 把高速缓存看作是一个先进先出的队列
        * 优先替换最先进入队列的字块
    * 最不经常使用算法（LFU）
        * 优先淘汰最不经常使用的字块
        * 需要额外的空间记录字块的使用频率
    * 最近最少使用算法（LRU）
        * 优先淘汰一段时间内没有使用的字块
        * 有多种实现方法，一般使用双向链表
        * 把当前访问节点置于链表前面（保证链表头部节点是最近使用的）
        * 运行示例
        * 假设缓存有 4 个字块，() 表示下一次正在使用的字块，[] 表示淘汰的字块，左侧为序列头，右侧为序列尾
            * 第 1 次使用：(1) 1
            * 第 2 次使用：(2) 2 1
            * 第 3 次使用：(4) 4 2 1
            * 第 4 次使用：(7) 7 4 2 1
            * 第 5 次使用：(5) 7 4 2 \[1\]
            * 第 6 次使用：(4) 4 5 7
            * 第 7 次使用：(6) 4 5 7 \[2\]
            * 第 8 次使用：(1) 1 6 4 5 \[7\]
            * 第 9 次使用：(6) 6 1 4 5
            * 第 10 次使用：(7) 7 6 1 4 \[5\]
            * 第 11 次使用：(4) 4 7 6 1 \[4\]
            * 第 12 次使用：(1) 1 4 7 6
